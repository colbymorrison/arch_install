Semantic Actions Phase 2: Code Generation for Simple Expressions

Actions: 30, 31, 40, 41, 42, 43, 44, 45, 46, 48, 55, 56

You will be implementing the semantic actions which handle the
generation of code for simple expressions. In the later
phases you will generate code for more complex expression, such
as procedure and function calls.

You need to update a few of the actions from the last phase.
First, update action 3 so that it will also handle local memory.
Secondly, add code to generate the first two lines of every TVI
file, "call main 0" and "exit" to the end of action 9. In Java,
this will look like:
  generate("call", "main", "0");
  generate("exit");
The details of the generate function are detailed later in this
document.
MAKE SURE TO DO THIS!

You also need to insert MAIN, READ, and WRITE into your global
symbol table as procedures with 0 parameters. This is to mark
these words as reserved.

Before you implement the new actions, you will need to set up
a few other things:

    - a global store field to keep track of an alloc statement,
      which can be filled in after its value is known
          - in Java, this might look like
            private int globalStore;
            and should be initialized to 0

    - a symbol table to store constant entries. This means that
      the compiler should have three symbol tables-- the global
      table, the local table and the constant table

    - a quadruple class which represents one TVI operation
      ex: "alloc 20", "move 4, _11", "mul _1, _11, _9"

    - a quadruples class which stores all of the TVI code
      generated so far (see the example on the course website)

    - a generate function, to be called in the semantic actions,
      which is responsible for generating the appropriate TVI
      code and storing it in the quadruples class

      ex: "generate(ltof, id2 temp)" would generate the quadruple
          "ltof {memory location of id2} {memory location of temp}"
          if id2 is stored at global memory address 12 and temp 1 is 
          stored at global memory address 14, then the quadruple generated
          will be "ltof _12, _14"

         - the generate function is responsible with finding the memory
           location of its arguments and using their memory location in
           the generated quadruple
           ex: if id is at address 4 in global memory, then its address
               should be denoted "_4"
               the underscore means to look for the following address
               in global memory
           ex: if val is at address 2 in local memory, then its address
               should be denoted "%2"
               the percent sign means to look for the following address
               in local memory
         
         - so, generate must be able to tell, for a given symbol table
           entry, if that symbol table is in global or local memory. 
           One way to do this is to store all global addresses as negative
           and all local addresses as positive. Another is to include
           an extra field in the SymbolTableEntry which keeps track
           of which table it is in

         - it might be a good idea to implement a getSTEAddress() and a
           getSTEPrefix() function, with the following pseudocode, which
           responsible for determining or assigning a symbol table entry
           an address and determining the prefix of a symbol table entry

           int getSTEAddress(SymbolTableEntry ste) {
               if (ste is an ArrayEntry of a VariableEntry) {
                   // array entries and variable entries are
                   // assigned address when they are initialized
                   return ste.getAddress();
               }
               
               if (ste is a ConstantEntry) {
                   // constants do not have an address, and a
                   // temporary variable must be created to store it
                   VariableEntry temp = create("temp", ste.getType());
                   // move the constant into the temporary variable
                   generate("move", ste.getName(), temp);
                   // return the address of the temporary variable
                   return temp.getAddress();
               }
           }

           String getSTEPrefix(SymbolTableEntry ste) {
               if (global) {
                   return "_";
               }
               else { // local
                   SymbolTableEntry entry = localTable.lookup(ste.getName());
                   if (entry == null) { // entry is a global variable
                       return "_";
                   }
                   else {
                       return "%";
                   }
               }
           }

    - a create function, which is responsible for inserting a new variable
      entry into the appropriate symbol table and associating it with a
      valid memory address
        - see below for a pseudocode outline of create:
          VariableEnry create(name, type) {
              VariableEntry ve = new VariableEnry();
              ve.type = type;
              ve.value = name;
              // store the address as negative to distinguish between
              // temporary variables
              ve.address = -1 * (globalMemory or localMemory);
              increment globalMemory or localMemory;
              insert ve into global or local symbol table;
              return ve;
          }
        
        - oftentimes, create will be used to create a new temporary
          variable so it will be necessary to implement a way to
          automatically assign a unique name when one is not provided
            - one way to do this is to keep track of how many temporary
              variables have been created and appending the number to
              "temp"
            - this will result in creating temporary variables with names
              like "temp1", "temp4", etc.

    - a typecheck function, which is responsible for checking the type
      of two ids with the following specifications:
        int typeCheck(id1, id2) will return
          0    if id1 and id 2 are both integers
          1    if id1 and id2 are both reals
          2    if id1 is real and id2 is integer
          3    if id1 is integer and id2 is real

    - a backpatch function with the following specification:
        void backpatch(int i, int x)
          inserts x in the second field of the quadruple at index i
          in quadruples
 
    - a lookup function, with the following specification:
        SymbolTableEntry lookupID(Token id) {
            // first look in the local table
            SymbolTableEntry ste = localTable.lookup(id);
            // if id is not in the local table
            if (ste == null) {
                // then look in the global table
                ste = globalTable.lookup(id);
            }
            return ste;
        }

NOTE: It might be a good idea to break this phase up into the following
      steps:
    1. Insert reserved words, implement changes to previous actions,
       the global store variable, quadruple, quadruples, and generate
    2. Implement actions 55 and 56
    3. Implement create and typecheck
    4. Implement the remaining actions


#30  : SymbolTableEntry id = lookupID(token);
       if (id is not found) {
           throw undeclared variable error;
       }
       stack.push(id);

#31  : SymbolTableEntry id2 = stack.pop();
       // offset will be implemented in later actions
       SymbolTableEntry offset = null;
       SymbolTableEntry id1 = stack.pop();

       if (typeCheck(id1, id2) == 3) {
           throw type mismatch error;
       }
       if (typeCheck(id1, id2) == 2) {
           VariableEntry temp = create("temp", TokenType.REAL);
           generate("ltof", id2, temp);
           if (offset == null) {
               generate("move", temp, id1);
           } else {
               generate("stor", temp, offset, id1);
           }
       } else {
           if (offset == null) {
               generate("move", id2, id1);
           } else {
               generate("stor", id2, offset, id1);
           }
       }

#40  : // the token should be a sign (unary plus or minus)
       stack.push(token);

#41  : SymbolTableEntry id = stack.pop();
       Token sign = stack.pop();
       if (sign == UNARYMINUS) {
           VariableEntry temp = create("temp", id.getType());
           if (id.getType() == TokenType.INTEGER) {
               generate("uminus", id, temp);
           } else {
               generate("fuminus", id, temp);
           }
           stack.push(temp);
       } else {
           stack.push(id);
       }

#42  : // the token should be an operator
       stack.push(token);

#43  : SymbolTableEntry id2 = stack.pop();
       // this is one place where the operator from action 42 is popped
       Token operator = stack.pop();
       // get the TVI opcode associated with the operator token
       // ex. for a token representing addition, opcode would be "add"
       String opcode = operator.getOpCode();
       SymbolTableEntry id1 = stack.pop();

       if (typeCheck(id1, id2) == 0) {
           VariableEntry temp = create("temp", TokenType.Integer);
           generate(opcode, id1, id2, temp);
           stack.push(temp);
       } else if (typeCheck(id1, id2) == 1) {
           VariableEntry temp create("temp", TokenType.REAL);
           generate("f" + opcode, id1, id2, temp);
           stack.push(temp);
       } else if (typeCheck(id1, id2) == 2) {
           VariableEntry temp1 = create("temp", TokenType.REAL);
           VariableEntry temp2 = create("temp", TokenType.REAL);
           generate("ltof", id2, temp1);
           generate("f" + opcode, id1, temp1, temp2);
           stack.push(temp2);
       } else if (typeCheck(id1, id2) == 3) {
           VariableEntry temp1 = create("temp", TokenType.REAL);
           VariableEntry temp2 = create("temp", TokenType.REAL);
           generate("ltof", id1, temp1);
           generate("f" + opcode, temp1, id2, temp2);
           stack.push(temp2);
       }

#44  : // the token passed to the semantic actions should be an 
       // operator
       // although this action is currently identical to
       // action 42, it will change in later phases
       stack.push(token);

#45  : SymbolTableEntry id2 = stack.pop();
       Token operator = stack.pop();
       String opcode = operator.getOpCode();
       SymbolTableEntry id1 = stack.pop();

       if (typeCheck(id1, id2) != 0 && 
          (operator == MOD || operator == DIV) {
           // MOD and DIV require integer operands
           throw bad parameter error; 
       }
       
       if (typeCheck(id1, id2) == 0) {
           if (operator == MOD) {
               VariableEntry temp1 = create("temp", TokenType.INTEGER);
               VariableEntry temp2 = create("temp", TokenType.INTEGER);
               VariableEntry temp3 = create("temp", TokenType.INTEGER);
               generate("div", id1, id2, temp1);
               generate("mul", id2, temp1, temp2);
               generate("sub", id1, temp2, temp3);
               stack.push(temp3);
           } else if (operator == /) {
               VariableEntry temp1 = create("temp", TokenType.REAL);
               VariableEntry temp2 = create("temp", TokenType.REAL);
               VariableEntry temp3 = create("temp", TokenType.REAL);
               generate("ltof", id1, temp1);
               generate("ltof", id2, temp2);
               generate("fdiv", temp1, temp2, temp3);
               stack.push(temp3);
           } else {
               VariableEntry temp = create("temp", TokenType.INTEGER);
               generate(opcode, id1, id2, temp);
               stack.push(temp);
           }
       } else if (typeCheck(id1, id2) == 1) {
           VariableEntry temp = create("temp", TokenType.REAL);
           generate("f" + opcode, id1, id2, temp);
           stack.push(temp);
       } else if (typeCheck(id1, id2) == 2) {
           VariableEntry temp1 = create("temp", TokenType.REAL);
           VariableEntry temp2 = create("temp", TokenType.REAL);
           generate("ltof", id2, temp1);
           generate("f" + opcode, id1, temp1, temp2);
           stack.push(temp2);
       } else if (typeCheck(id1, id2) == 3) {
           VariableEntry temp1 = create("temp", TokenType.REAL);
           VariableEntry temp2 = create("temp", TokenType.REAL);
           generate("ltof", id1, temp1);
           generate("f" + opcode, temp1, id2, temp2);
           stack.push(temp2);
       }

#46  : if (token.getType() == TokenType.IDENTIFIER) {
           // look for the token in the global or local symbol
           // table, as appropriate
           SymbolTableEntry id = lookupID(token.getValue());
           // if token is not found
           if (id == null) {
               throw undeclared variable error;
           }
           stack.push(id);
       } else if (token.getType() == TokenType.INTCONTSTANT ||
                 token.getType() == TokenType.REALCONSTANT) {
           // look for the token in the constant symbol table
           SymbolTableEntry id = lookupConstant(token.getValue());
           // if token is not found
           if (id == null) {
               if (token.getType() == TokenType.INTCONSTANT) {
                   id = contant entry of type integer and value from token;
               } else if (token.getType() == TokenType.REALCONSTANT) {
                   id = constant entry of type real and value from token;
               }
               insert id into the constant table;
           }
           stack.push(id);
       }

#48  : // offset will be implemented in later actions
       SymbolTableEntry offset = null;
       if (offset != null) {
           SymbolTableEntry id = stack.pop();
           VariableEntry temp = create("temp", id.getType());
           generate("load", id, offset, temp);
           stack.push(temp);
       }

#55  : backpatch(globalStore, globalMemory);
       generate("free", globalMemory);
       generate("procend");

#56  : generate("procbegin", "main");
       globalStore = quadruples.getNextQuad();
       // the underscore as the second arguement in generate
       // is a placeholder that will be filled in later by backpatch
       generate("alloc", "_");